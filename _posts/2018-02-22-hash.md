---
layout: post
title: 哈希
categories: [algorithm]
description: some word here
keywords: hash
---

# hash

把任意长度的输入，通过hash算法，变换成固定长度的输出，该输出就是散列值(在哈希表中就是存放位置)。这种转换是一种压缩映射。将一个大的空间空过散列映射压缩至一个相对而言更小的空间。

## hash函数

要完成对输入的映射，需要经过哈希函数。但是所有的哈希函数都会发生一个问题就是哈希碰撞也就是冲突。简单来说对于输入7,4 经过函数f(x) = x % 3，的变换输出的都为1。这时就发生所谓的哈希碰撞。而这种情况的发生理论上是无法避免的。但是可以通过精心的设计哈希表(存放散列值)和哈希函数，以尽可能的降低冲突发生的概率。
以及制定可行的预案，以便在发生冲突的时候，能够尽快予以排解。

### hash函数的标准与制定原则

1. 确定：对于同一输入，总是被映射至同一地址。
2. 快速：映射应快速的完成。
3. 满射：映射尽可能充分的覆盖整个空间(空间利用率较高)。
4. 均匀：输入映射到哈希表个位置的概率尽量接近。

散列函数越是随机，越是没有规律更好

### 常用的哈希函数

#### 除余法

**hash(key) = key % M**

  使用这个方法时若 M = 2^k，其效果相当于截取key的最后k位，对前面n-k位没有影响。发生冲突的概率大。
  当M为素数时，数据对哈希表的覆盖最充分，分布最均匀。

#### MAD法

**hash(key) = (a * key + b) % M**

解决除余法的两个缺陷
1. 不动点：无论表长M取值如何时，总有hash(0) = 0
2. 零阶均匀: [0， R)的关键码，平均分配至M个桶；但相邻关键码的哈希地址也必相邻。

MAD法增加了偏移量b 步长分别解决了这两个问题。

#### 平方取中法

取key^2的中间若干位，构成地址

hash(123) = 512 //保留key^2 = 15129 的中间三位512

#### 折叠法

将key分割成等宽的若干段，取其总和作为地址

hash(123456789) = 1236 //123 + 456 + 789 自左向右
hash(123456789) = 1566 //123 + 654 + 789 往复折返

#### 位异或法

将key分割成等宽的二进制端，经异或运算得到地址

hash(110011011) = 110 //110 ^ 011 ^ 011 自左向右
hash(110011011) = 011 //110 ^ 110 ^ 011 往复折返

#### 伪随机数法

hash(key) = rand(key) =  [rand(0) * a^key] % M

rand(0) 直接可以使用编程语言实现的随机数发生器。
但是(伪)随机数发生器的实现，因具体平台、不同历史版本创建的哈希表可移植性差，应慎用。

#### 多项式法

对于输入未必都是整数，所以需要进行预处理将其转换为整数，即hashcode。

### 排解冲突

任何一种可行的排解方法，都应该是事先约定好的预案。

#### 多槽位

将桶单元细分成若干槽位(slot)存放(与同一单元)冲突的词条。
但是，需要为每个桶配备多少个槽才能使时间效率为O(1)，预留过多则空间浪费。无论预留多少，极端情况下仍然有可能不够。

#### 独立链

对于上面的存在的问题可以改为在每个桶中存放一个链表。
这样，无需为每个桶预备多个槽位，任意多个冲突也可解决。删除操作实现简单、统一。
但是，也存在下面的缺点。 链表需要额外空间、节点需要动态申请更重要的是空间未必连续分布，系统缓存几乎失效。

#### 开放定址(open addressing)

也就是closed hashing(闭哈希)，为每个桶都事先约定若干备用桶(发生冲突的都放这里)它们构成一个查找链probing sequence/chain

查找：沿查找链，逐个转向下一桶单元，直到命中成功，或则抵达一个空桶(已遍历所有冲突的词条)则失败。

查找链的组织方法：

1. 线性试探(linear probing)

一旦冲突，则试探后一紧邻单元；
[hash(key) + 1] % M
[hash(key) + 2] % M
[hash(key) + 3] % M
[hash(key) + 4] % M
	.......
直到命中成功，或抵达空桶失败。
优点：无需附加的(链表、溢出区等)空间
	  查找链具有局部性，可充分利用系统缓存，有效减少IO
缺点：操作时间 > O(1)
	  冲突增多--以往的冲突，会导致后续的冲突。
对于开放定址如果需要删除某一词条应如何完成？
按照开放定址策略：先后插入、相互冲突的一组词条，将存放与同一查找链中。
现在需删除其中某一词条，如果直接删除，查找链将被切断，后续词条将丢失--存在却访问不到。
懒惰删除(lazy removal)：仅做删除标记。当做查找操作时不在此中断。插入操作时，当做空桶进行插入。

2. 平方试探(Quadratic probing)

线性试探存在的问题就是试探位置间距太近。而采用平方试探就可以拉开试探的间距。
以平方数为距离，确定下一试探桶单元
[hash(key) + 1^2] % M
[hash(key) + 2^2] % M
[hash(key) + 3^2] % M
[hash(key) + 4^2] % M
	.......
分析：
数据聚集现象有所缓解
查找链上，各桶间距线性递增，一旦冲突，可聪明地跳离是非之地。
但是平方试探正在一定程度上破坏数据访问的局部性、若涉及外存，IO将激增。通常情况下这种影响不会很大。
平方试探还存在这样一个问题，因为不是一个一个往下试探。可能存在空桶但依据平方试探策略却无法找出。M若为素数 n^2 % M 的可能取值恰好会有M/2种。为了利用余下了空间可以使用双向平方试探。

3. 双向平方试探

自冲突位置起，依次向前向后试探
[hash(key) + 1^2] % M
[hash(key) - 1^2] % M
[hash(key) + 2^2] % M
[hash(key) - 2^2] % M
[hash(key) + 3^2] % M
[hash(key) - 3^2] % M
	.....
正向和逆向的子查找链，个包含[M/2]个互异的桶。如果两个子链中除0外没有相等的元素那么正好遍历所有桶([m/2] - 1 = M)
当表长取素数M = 4 * k + 3(模4余3)，**必然可以保证查找链的前M项均互异**



